# 1.Linux中文件权限
（1）文件类型和文件权限由 10 个字符组成：
第 1 位表示文件的类型；
第 2 - 4 位表示文件所有者对文件的权限；（-a）第 5 - 7 位表示文件所有者所在组的用户对文件的权限；（-g）第 8 - 10 位表示其他用户对文件的权限；（-o）其中 r 表示可读，w 表示可写，x 表示可执行，- 表示没有权限。
如果可读，权限二进制为 100，十进制是4；如果可写，权限二进制为 010，十进制是2；如果可执行，权限二进制为 001，十进制是1；所以 rw-r--r-x 权限的十进制表示为 645。即（4+2+0）（4+0+0）(4+0+1)。

（2）新目录的默认最大权限为777（rwxrwxrwx）。执行'umask 0027'后，umask值027（0027等价于027）表示：用户权限无屏蔽（umask 0），组权限屏蔽写（umask 2，屏蔽w位），其他权限屏蔽所有（umask 7）。实际权限计算为：用户权限rwx（7），组权限r-x（5），其他权限---（0），因此最终权限为750（rwxr-x---）。

（3）文件aaa的访问权限为rw-r--r--,现要增加所有用户的执行权限和同组用户的写权限，可以使用chmod命令,有两种方式:字母(symbolic)方式和数字(octal)方式。原始权限rw-r--r--为644，chmod a+x,g+w aaa
- a+x 表示给所有用户(all)增加执行权限
- g+w 表示给同组用户(group)增加写权限
- 最终权限为rwxrwxr-x(775)可用chmod 775 aaa表示。

# 2.
每个线程都有自己独立的栈空间，而不是共享相同的栈。这是为了保证线程运行时的局部变量、函数调用等操作的独立性。但是每个线程可以共享一个堆并从中读取数据。

# 3.静态库与动态库
在Linux系统编程中，库是一组预先编写好的代码，可以在多个程序中使用。根据链接方式的不同，库可以分为静态库和动态库。
## 静态库
静态库是在编译时将库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时不再需要库文件。静态库的后缀名一般为.a。
## 静态库的特点
编译时链接：库代码被嵌入到可执行文件中，生成的可执行文件可以独立运行。
文件体积较大：由于库代码被嵌入到可执行文件中，生成的可执行文件体积较大。
易于分发：所有依赖库都已经包含在可执行文件中，分发和部署相对简单。
更新麻烦：如果需要更新库代码，必须重新编译所有依赖该库的应用程序。
## 动态库
动态库（也叫共享库）是在程序运行时加载的库。动态库的文件扩展名通常是.so。
## 动态库的特点
运行时链接：动态库在程序运行时被加载，可以按需加载。
可执行文件小：由于不包含库的实现代码，可执行文件较小。
内存共享：多个进程可以共享同一个动态库的内存实例，节省系统资源。
库独立更新：只需更新动态库文件，而无需重新编译依赖这些库的所有应用程序。
## 静态库和动态库的比较
链接时间：静态库在编译时链接，动态库在运行时链接。
可执行文件大小：静态库生成的可执行文件较大，动态库生成的可执行文件较小。
内存消耗：静态库每个使用同一静态库的程序都有一份库代码拷贝，动态库多个进程可以共享同一份动态库的内存映像。
更新和维护：静态库更新库时需要重新编译所有依赖该库的程序，动态库更新库后所有依赖该库的程序在下次启动时都会使用新库。
## 总结
静态库和动态库在Linux系统编程中各有优劣。静态库简单易管理，但消耗更多的磁盘空间和内存，适用于不频繁更新的库。动态库节省资源，适用于共享库更新频繁的场景，但需要注意库版本兼容性问题。

# 4.Linux VFS的通用的文件模型（Common FileModel）
超级块对象(Superblock Object) - 它存储文件系统的控制信息,包括文件系统类型、大小、状态等重要元数据信息。
索引节点对象(Inode Object)- 它包含了文件的元数据信息,如文件大小、所有者、访问权限等,是VFS中最重要的数据结构之一。
文件对象(File Object) - 它代表进程打开的文件,包含文件指针位置等信息,是进程与文件交互的接口。